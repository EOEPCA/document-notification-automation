{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Warning</p> <p>Work in progress\u2026 </p> <p>The Notification and Automation Building Block is designed to enable efficient communication and automated processes within EOEPCA+.</p> <p>The Notification &amp; Automation BB is designed to facilitate intra-Building-Block asynchronous communications. This means it allows different parts of the system to communicate with each other without needing to wait for responses, thereby improving efficiency and responsiveness.</p> <p>It supports triggers that can initiate automated behaviour. These triggers can be based on external events (eg. events from object storage,  etc) or can be scheduled to occur at certain times.</p> <p>It supports triggers that can initiate automated behaviour. These triggers can be based on external events (eg. events from object storage,  etc) or can be scheduled to occur at certain times.</p>"},{"location":"#about-the-notification-and-automation-building-block","title":"About the Notification and Automation Building Block","text":"<p>The Notification &amp; Automation Building Block is composed out of two core components:</p> <ul> <li>Notification Service: This component is responsible for handling asynchronous event-based messaging within the system. It allows different Building Blocks to send and receive notifications or alerts about certain events, enabling them to react to changes or updates without direct interaction.  </li> <li>Automation Service: This component allows for the definition and execution of automated tasks based on specific triggers. These can be data-driven, where certain data conditions initiate an action, or scheduled, where actions are performed at predetermined times.</li> </ul> <p>The Notification and Automation Building Block builds upon the KNative framework, primarly around the functionality offered by KNative-Eventing. KNative-Eventing manages events, allowing applications to interface with external event sources, register and subscribe to events, and filter them. It decouples event producers from consumers, providing a flexible event-driven architecture.</p>"},{"location":"admin/configuration/","title":"Configuration","text":"<p>How the BB is configured - with examples etc.</p> <p>Warning</p> <p>Work in progress\u2026 </p>"},{"location":"admin/maintenance/","title":"Maintenance","text":"<p>Administrative and remedial activities to be performed on a running BB instance</p> <p>Warning</p> <p>Work in progress\u2026 </p>"},{"location":"api/endpoint-specification/","title":"Specification","text":"<p>Details of the API specification.</p> <p>Warning</p> <p>Work in progress\u2026 </p>"},{"location":"api/usage/","title":"Usage","text":"<p>API usage descriptions and examples.</p> <p>Warning</p> <p>Work in progress\u2026 </p>"},{"location":"design/more-design/","title":"More design\u2026","text":"<p>Further elaboration of design\u2026</p> <p>Warning</p> <p>Work in progress\u2026 </p>"},{"location":"design/overview/","title":"Architecture","text":"<p>Warning</p> <p>Work in progress\u2026 </p> <p>The notification component is built around the KNative-Eventing and provides the core events for the automation component.</p> <p>The notification component of the building block is composed out of two components:</p> <ul> <li>Producers</li> <li>Consumers</li> </ul> <p>Overall the common interaction sequence for EOEPCA+ is depicted in the following sequence diagram:</p> <pre><code>sequenceDiagram\n    actor ExtProd as External Producer\n    create participant ExternalSinkBinding as External Sink\n    Note over ExtProd,ExternalSinkBinding: OIDC AuthenticatedOPA Authorized\n    alt CloudEvent\n        ExtProd -&gt;&gt; ExternalSinkBinding: Publish Event\n    else Alternative Enconding\n        ExtProd -&gt;&gt; ExternalSinkBinding: Publish Event\n        ExternalSinkBinding -&gt;&gt; EventEncoder: Convert to CloudEvent\n        EventEncoder --&gt; ExternalSinkBinding: Return Generated Event\n    end\n\n    break authorization fails\n        ExternalSinkBinding--&gt;&gt;ExtProd: report failure\n    end\n\n    create participant KNativeBroker as KNative Broker\n\n    ExternalSinkBinding -&gt;&gt; KNativeBroker: Publish CloudEvent\n    Note right of ExternalSinkBinding: Controlled by  SinkBinding\n    create participant KNativeFlows as KNative Flows\n    KNativeBroker -&gt;&gt; KNativeFlows: Pass CloudEvent to Flows\n    KNativeFlows --&gt;&gt; KNativeBroker: Reply with [potential] responses\n</code></pre>"},{"location":"design/overview/#components","title":"Components","text":"<p><code>Sinks</code> are the core concept of the notification component. They are Kubernetes resources that act as destinations (basically consumers) for events in EOEPCA. They enable decoupled communication betweent event producers and consumers by providing an abstraction layer for event routing. <code>Sinks</code> are addressable resources and they expose an URL endpoint for receiving events (encoded as <code>CloudEvents</code>) via HTTP POST. <code>Sinks</code> are the foundation of EOEPCAs notification system as they enable flexible integration between event producers and consumers.</p> <pre><code>flowchart LR\n    Source --&gt;|POST CloudEvent| Broker\n    Broker --&gt; TriggerFilter[Trigger Filter]\n    TriggerFilter --&gt; |POST CloudEvent| Sink\n</code></pre>"},{"location":"design/overview/#producers","title":"Producers","text":"<p>Producers are components responsible for generating and emitting events. The events are further captured by <code>Sinks</code> (usually Brokers or Channels) and further routed by the notification system. </p> <p>Events are normally generated when a state changes (or an action is triggered) in a component. As previously mentioned this events should be encoded as CloudEvent compliant payload. </p> <p>Producers are completly decoupled form consumers and can produce events regardless if there are consumers present.</p> <p>Any component can act as a producer as long as it cand issue a HTTP POST to a specific endpoint (usually a broker endpoint, or sink).</p> <p>The location of the endpoint/sink where events should be directed can be handles using multiple approaches:</p> <ul> <li>Hard Coded : <code>Sink</code> address can be hardcoded in the application (eg. http://eoepca-broker.default.svc.cluster.local. Destination sink could be made configurable in the Kubernetes Deployment/StatefulSet based on a Helm value.</li> <li>Dynamically Injected:  KNative-Eventing facilitates the automatic injection of the destination <code>Sink</code> using a <code>SinkBinding</code>. Basically KNative injects two environment valiables, as follows: <code>K_SINK</code> representing the URL of the resolved destination sink and <code>K_CE_OVERRIDES</code> containing a JSON object that specifies overrides to the outbound event.</li> </ul> <p>The recommended approach in EOEPCA+ is a mix between the two approaches:</p> <ul> <li>Applications should be aware that if the <code>K_SINK</code> environment variable is present then it is expected to <code>POST</code> CloudEvents to that specific URL</li> <li>Applications should handle with care the <code>K_CE_OVERRIDES</code> as it might also overide the <code>type</code> attribute and respect that specific overide.</li> </ul>"},{"location":"design/overview/#consumers","title":"Consumers","text":"<p>In EOEPCA+ an event consumer cand be represented by any component which can receive a HTTP Post. Basically any HTTP enabled application can act as a <code>Sink</code> and receive events.</p> <p>Applications/Sinks which receive and return events are called Callable Sinks. If they are triggered by a Broker with an event then the returned events is ingested back by the Broker entering again the event processing/routing system.</p>"},{"location":"design/overview/#type-hierarchy","title":"Type Hierarchy","text":"<p>The proposed event type naming scheme in EOEPCA+ adheres tot the core naming structure in KNative. Particularly we use recommend the reverse domain notation to avoid collisions.</p> <p>This approach results in a hierarchical format like:</p> <pre><code>&lt;domain&gt;.&lt;component&gt;.&lt;event-category&gt;.&lt;action&gt;\n</code></pre> <p>Example: <code>org.eoepca.processing.application-package.published</code></p> <p>Events generated by internal EOEPCA+ components should always issue events prefixed by the above schema (prefixed by <code>org.eoepca</code> and adhering as much as possible to the <code>buidling-block.category.action</code> convention). </p>"},{"location":"getting-started/more-getting-started/","title":"More getting started\u2026","text":"<p>Further elaboration of Getting Started\u2026</p> <p>Warning</p> <p>Work in progress\u2026 </p>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Quick start instructions - including installation, e.g. of a local instance.</p> <p>Warning</p> <p>Work in progress\u2026 </p>"},{"location":"usage/consuming/","title":"Consuming Events","text":"<p>In EOEPCA+ notification events consumers can be any URL addressable <code>Sink</code>, both internal and external.</p> <p>Consumers can register to events using two approaches:</p> <ul> <li>Creating a trigger</li> <li>Subscribing to a channel</li> </ul> <p>Registering to events using a trigger can be achieved by using the cli:</p> <pre><code>kn trigger create on-resource-added --broker primary \\\n    --filter type=org.eoepca.resource-registration.resource.added \\\n    -s http://my-service.default.svc.cluster.local\n</code></pre> <p>The equivalent registration using a kubernetes manifest can be achived with:</p> <pre><code>apiVersion: eventing.knative.dev/v1\nkind: Trigger\nmetadata:\n  labels:\n    eventing.knative.dev/broker: primary\n  name: on-resource-added\n  namespace: default\nspec:\n  broker: primary\n  filter:\n    attributes:\n      type: org.eoepca.resource-registration.resource.added\n  subscriber:\n    uri: http://my-service.default.svc.cluster.local\n</code></pre> <p>After the registration the HTTP endpoint will receive CloudEvents using <code>HTTP POST</code>, with attributes encoded as <code>HTTP</code> headers and the event as the POST body.</p>"},{"location":"usage/howtos/","title":"How-Tos","text":"<p>How-tos to communicate usage by example.</p> <p>Warning</p> <p>Work in progress\u2026 </p>"},{"location":"usage/producing/","title":"Producing Events","text":"<p>Producers are components responsible for generating and emitting events. The events are further captured by <code>Sinks</code> (usually Brokers or Channels) and further routed by the notification system. </p> <p>As presented in the architecture section event producers can be any application running inside Kubernetes as long as it can <code>HTTP POST</code> events to a resolved <code>Sink</code>.</p> <p>The recommended approach in EOEPCA+ is the usage of <code>SinkBindings</code> for connecting existing applications to the notification system. This method allows extended flexibility without requiring significant changes to the code base.</p> <p>In order for applications to be compatible with the <code>SinkBinding</code> approach they must follow the following conventions:</p> <p>Applications should check if two specific environment variables are set:</p> <ul> <li><code>K_SINK</code> representing the URL of the resolved destination sink - <code>K_CE_OVERRIDES</code> containing a JSON object that specifies overrides to the outbound event.</li> </ul> <p>If the <code>K_SINK</code> environment variable is present then they can produce events otherwise they can supress them.</p> <p>Applications compliant with the above conventions can be direct externally to post to a specific <code>sink</code> using either the <code>kn</code> command line tool or declaratively using the KNative-Eventing CRDs.</p> <p>For example the following <code>SinkBinding</code> directs messages generated by <code>resource-catalogue-service</code> to the broker named <code>primary</code> in the <code>default</code> namespace.</p> <pre><code>apiVersion: sources.knative.dev/v1\nkind: SinkBinding\nmetadata:\n  name: bind-resource-catalogue-service\nspec:\n  subject:\n    apiVersion: apps/v1\n    kind: Deployment\n    namespace: resource-registration\n    name: resource-catalogue-service\n  sink:\n    ref:\n      apiVersion: eventing.knative.dev/v1\n      kind: Broker\n      name: primary\n      namespace: default\n</code></pre>"},{"location":"usage/producing/#python-examples","title":"Python Examples","text":"<p>An example code snippet for applications adhering to the <code>SinkBinding</code> conventions:</p> <pre><code>import os\nimport requests\nfrom cloudevents.http import CloudEvent\nfrom cloudevents.conversion import to_binary, to_structured\n\nk_sink = os.environ.get(\"K_SINK\", None)\nk_ce_overrides_str = os.environ.get(\"K_CE_OVERRIDES\", None)\n\n\nif k_sink is not None:\n    data = {\n        # Something specific to the Building Block\n    }\n    attributes = {\n        \"type\": \"org.eoepca.resource-registration.resource.added\",\n        \"source\": \"http://resource-registration.apx.develop.eoepca.org/catalogue\" \n    }\n    event = CloudEvent(attributes, data)\n    headers, body = to_binary(event)\n    requests.post(k_sink, data=body, headers=headers)\n</code></pre> <p>Other applications can directly post to the broker endpoint, for example:</p> <p>http://broker-ingress.knative-eventing.svc.cluster.local/default/primary</p>"},{"location":"usage/tutorials/","title":"Tutorials","text":"<p>Tutorials as a learning aid.</p> <p>Warning</p> <p>Work in progress\u2026 </p>"}]}